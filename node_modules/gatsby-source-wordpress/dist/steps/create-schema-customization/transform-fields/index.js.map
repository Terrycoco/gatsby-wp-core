{"version":3,"file":"index.js","names":["handleCustomScalars","field","fieldTypeIsACustomScalar","type","kind","typeIsASupportedScalar","name","fieldTypeOfTypeIsACustomScalar","ofType","getAliasedFieldName","fieldAliases","returnAliasedFieldName","excludeField","fieldName","thisTypeSettings","fieldBlacklist","parentTypeSettings","parentInterfacesImplementingTypeSettings","fieldOfTypeWasFetched","excludeFieldNames","includes","find","typeSetting","excludedFieldName","exclude","args","arg","findTypeName","transformFields","fields","parentType","parentInterfacesImplementingTypes","gatsbyNodeTypes","length","getTypeSettingsByType","map","transformedFields","reduce","fieldsObject","typeMap","store","getState","remoteSchema","get","includedChildFields","filter","childFieldTypeSettings","Array","isArray","transform","description","fieldTransformers","test","transformerApi","transformedField","resolve","buildDefaultResolver"],"sources":["../../../../src/steps/create-schema-customization/transform-fields/index.js"],"sourcesContent":["import { fieldTransformers } from \"./field-transformers\"\nimport store from \"~/store\"\n\nimport {\n  fieldOfTypeWasFetched,\n  typeIsASupportedScalar,\n  getTypeSettingsByType,\n  findTypeName,\n} from \"~/steps/create-schema-customization/helpers\"\n\nimport { buildDefaultResolver } from \"./default-resolver\"\n\nconst handleCustomScalars = field => {\n  const fieldTypeIsACustomScalar =\n    field.type.kind === `SCALAR` && !typeIsASupportedScalar(field.type)\n\n  if (fieldTypeIsACustomScalar) {\n    // if this field is an unsupported custom scalar,\n    // type it as JSON\n    field.type.name = `JSON`\n  }\n\n  const fieldTypeOfTypeIsACustomScalar =\n    field.type.ofType &&\n    field.type.ofType.kind === `SCALAR` &&\n    !typeIsASupportedScalar(field.type)\n\n  if (fieldTypeOfTypeIsACustomScalar) {\n    // if this field is an unsupported custom scalar,\n    // type it as JSON\n    field.type.ofType.name = `JSON`\n  }\n\n  return field\n}\n\n// this is used to alias fields that conflict with Gatsby node fields\n// for ex Gatsby and WPGQL both have a `parent` field\nexport const getAliasedFieldName = ({ fieldAliases, field }) =>\n  fieldAliases && fieldAliases[field.name]\n    ? fieldAliases[field.name]\n    : field.name\n\nexport const returnAliasedFieldName = ({ fieldAliases, field }) =>\n  fieldAliases && fieldAliases[field.name]\n    ? `${fieldAliases[field.name]}: ${field.name}`\n    : field.name\n\nconst excludeField = ({\n  field,\n  fieldName,\n  thisTypeSettings,\n  fieldBlacklist,\n  parentTypeSettings,\n  parentInterfacesImplementingTypeSettings,\n}) =>\n  // this field wasn't previously fetched, so we shouldn't\n  // add it to our schema\n  !fieldOfTypeWasFetched(field.type) ||\n  // this field was excluded on it's parent fields Type\n  (parentTypeSettings.excludeFieldNames &&\n    parentTypeSettings.excludeFieldNames.includes(fieldName)) ||\n  // this field is on an interface type and one of the implementing types has this field excluded on it.\n  (parentInterfacesImplementingTypeSettings &&\n    parentInterfacesImplementingTypeSettings.find(\n      typeSetting =>\n        typeSetting.excludeFieldNames &&\n        typeSetting.excludeFieldNames.find(\n          excludedFieldName => fieldName === excludedFieldName\n        )\n    )) ||\n  // the type of this field was excluded via plugin options\n  thisTypeSettings.exclude ||\n  // field is blacklisted\n  fieldBlacklist.includes(fieldName) ||\n  // this field has required input args\n  (field.args && field.args.find(arg => arg.type.kind === `NON_NULL`)) ||\n  // this field has no typeName\n  !findTypeName(field.type) ||\n  // field is a non null object\n  // @todo this looks unnecessary. Need to look into why non null object types are excluded\n  (field.type.kind === `NON_NULL` && field.type.ofType.kind === `OBJECT`) ||\n  // field is a non null enum\n  (field.type.kind === `NON_NULL` && field.type.ofType.kind === `ENUM`)\n\n/**\n * Transforms fields from the WPGQL schema to work in the Gatsby schema\n * with proper node linking and type namespacing\n * also filters out unusable fields and types\n */\n\nexport const transformFields = ({\n  fields,\n  fieldAliases,\n  fieldBlacklist,\n  parentType,\n  parentInterfacesImplementingTypes,\n  gatsbyNodeTypes,\n}) => {\n  if (!fields || !fields.length) {\n    return null\n  }\n\n  const parentTypeSettings = getTypeSettingsByType(parentType)\n\n  const parentInterfacesImplementingTypeSettings =\n    parentInterfacesImplementingTypes\n      ? parentInterfacesImplementingTypes.map(type =>\n          getTypeSettingsByType(type)\n        )\n      : null\n\n  const transformedFields = fields.reduce((fieldsObject, field) => {\n    // if there's no field name this field is unusable\n    if (field.name === ``) {\n      return fieldsObject\n    }\n\n    const thisTypeSettings = getTypeSettingsByType(field.type)\n\n    const fieldName = getAliasedFieldName({ fieldAliases, field })\n\n    if (\n      excludeField({\n        field,\n        fieldName,\n        thisTypeSettings,\n        fieldBlacklist,\n        parentTypeSettings,\n        parentInterfacesImplementingTypeSettings,\n      })\n    ) {\n      return fieldsObject\n    }\n\n    const { typeMap } = store.getState().remoteSchema\n\n    const type = typeMap.get(findTypeName(field.type))\n\n    const includedChildFields = type?.fields?.filter(field => {\n      const childFieldTypeSettings = getTypeSettingsByType(field.type)\n      const fieldName = getAliasedFieldName({ fieldAliases, field })\n      return !excludeField({\n        field,\n        fieldName,\n        thisTypeSettings: childFieldTypeSettings,\n        fieldBlacklist,\n        parentTypeSettings: thisTypeSettings,\n        parentInterfacesImplementingTypeSettings,\n      })\n    })\n\n    // if the child fields of this field are all excluded,\n    // we shouldn't add this field\n    // @todo move this to a central location.\n    // if a type is missing all it's child fields due to exclusion\n    // it should be globally excluded automatically.\n    if (Array.isArray(includedChildFields) && !includedChildFields.length) {\n      return fieldsObject\n    }\n\n    field = handleCustomScalars(field)\n\n    const { transform, description } =\n      fieldTransformers.find(({ test }) => test(field)) || {}\n\n    if (transform && typeof transform === `function`) {\n      const transformerApi = {\n        field,\n        fieldsObject,\n        fieldName,\n        gatsbyNodeTypes,\n        description,\n      }\n\n      let transformedField = transform(transformerApi)\n\n      // add default resolver\n      if (typeof transformedField === `string`) {\n        // we need to add a custom resolver to override the default resolver\n        // and check for aliased fields\n        // fields are aliased automatically if they have conflicting types\n        // with other fields of the same name when placed in side-by-side\n        // inlineFragments on the same union or interface type.\n        transformedField = {\n          type: transformedField,\n          resolve: buildDefaultResolver(transformerApi),\n          description: field.description,\n        }\n      } else {\n        transformedField.description = field.description\n      }\n\n      fieldsObject[fieldName] = transformedField\n    }\n\n    return fieldsObject\n  }, {})\n\n  return transformedFields\n}\n"],"mappings":"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"}