{"version":3,"file":"field-transformers.js","names":["fieldTransformers","description","test","field","type","kind","ofType","transform","typeIsABuiltInScalar","name","typeName","findTypeName","normalizedTypeName","buildTypeName","fieldName","originalTypeName","typeKind","findTypeKind","normalizedType","resolve","source","resolvedField","autoAliasedFieldPropertyName","aliasedField","gatsbyNodeTypes","getGatsbyNodeTypeNames","pluginOptions","getPluginOptions","isAnInterfaceTypeOfGatsbyNodes","store","getState","remoteSchema","typeMap","get","possibleTypes","filter","possibleType","typeIsExcluded","every","includes","transformGatsbyNodeObject","find","transformListOfGatsbyNodes","transformListOfUnions","transformUnion"],"sources":["../../../../src/steps/create-schema-customization/transform-fields/field-transformers.js"],"sourcesContent":["import { buildTypeName, findTypeName, findTypeKind } from \"../helpers\"\nimport { transformUnion, transformListOfUnions } from \"./transform-union\"\nimport { transformGatsbyNodeObject } from \"~/steps/create-schema-customization/transform-fields/transform-object\"\nimport { transformListOfGatsbyNodes } from \"./transform-object\"\nimport { getGatsbyNodeTypeNames } from \"~/steps/source-nodes/fetch-nodes/fetch-nodes\"\nimport { typeIsABuiltInScalar } from \"~/steps/create-schema-customization/helpers\"\nimport store from \"~/store\"\nimport { typeIsExcluded } from \"~/steps/ingest-remote-schema/is-excluded\"\nimport { getPluginOptions } from \"~/utils/get-gatsby-api\"\n\nexport const fieldTransformers = [\n  {\n    description: `NON_NULL Scalar`,\n    test: field =>\n      field.type.kind === `NON_NULL` && field.type.ofType.kind === `SCALAR`,\n\n    transform: ({ field }) => {\n      if (typeIsABuiltInScalar(field.type)) {\n        return `${field.type.ofType.name}!`\n      } else {\n        return `JSON!`\n      }\n    },\n  },\n\n  {\n    description: `NON_NULL list type`,\n    test: field =>\n      field.type.kind === `NON_NULL` &&\n      field.type.ofType.kind === `LIST` &&\n      (field.type.ofType.name || field.type.ofType?.ofType?.name),\n\n    transform: ({ field }) => {\n      const typeName = findTypeName(field.type)\n      const normalizedTypeName = typeIsABuiltInScalar(field.type)\n        ? typeName\n        : buildTypeName(typeName)\n\n      return `[${normalizedTypeName}]!`\n    },\n  },\n\n  {\n    description: `NON_NULL lists of NON_NULL types`,\n    test: field =>\n      field.type.kind === `NON_NULL` &&\n      field.type.ofType.kind === `LIST` &&\n      field.type.ofType?.ofType?.kind === `NON_NULL`,\n\n    transform: ({ field, fieldName }) => {\n      const originalTypeName = findTypeName(field.type)\n      const typeKind = findTypeKind(field.type)\n\n      const normalizedType =\n        typeKind === `SCALAR` && typeIsABuiltInScalar(field.type)\n          ? originalTypeName\n          : buildTypeName(originalTypeName)\n\n      return {\n        type: `[${normalizedType}!]!`,\n        resolve: source => {\n          const resolvedField = source[fieldName]\n\n          if (typeof resolvedField !== `undefined`) {\n            return resolvedField ?? []\n          }\n\n          const autoAliasedFieldPropertyName = `${fieldName}__typename_${field?.type?.name}`\n\n          const aliasedField = source[autoAliasedFieldPropertyName]\n\n          return aliasedField ?? []\n        },\n      }\n    },\n  },\n\n  {\n    description: `Lists of NON_NULL builtin types`,\n    test: field =>\n      field.type.kind === `LIST` &&\n      field.type.ofType.kind === `NON_NULL` &&\n      (field.type.ofType.name ?? field.type.ofType?.ofType?.name) &&\n      typeIsABuiltInScalar(field.type),\n\n    transform: ({ field }) => `[${findTypeName(field.type)}!]`,\n  },\n\n  {\n    description: `Lists of NON_NULL types`,\n    test: field =>\n      field.type.kind === `LIST` &&\n      field.type.ofType.kind === `NON_NULL` &&\n      (field.type.ofType.name ?? field.type.ofType?.ofType?.name),\n\n    transform: ({ field }) => `[${buildTypeName(findTypeName(field.type))}!]`,\n  },\n\n  {\n    description: `ENUM type`,\n    test: field => field.type.kind === `ENUM`,\n    transform: ({ field }) => buildTypeName(field.type.name),\n  },\n\n  {\n    description: `Scalar type`,\n    test: field => field.type.kind === `SCALAR`,\n    transform: ({ field }) => {\n      if (typeIsABuiltInScalar(field.type)) {\n        return field.type.name\n      } else {\n        // custom scalars are typed as JSON\n        // @todo if frequently requested,\n        // make this hookable so a plugin could register a custom scalar\n        return `JSON`\n      }\n    },\n  },\n\n  {\n    description: `Gatsby Node Objects or Gatsby Node Interfaces where all possible types are Gatsby Nodes`,\n    test: field => {\n      const gatsbyNodeTypes = getGatsbyNodeTypeNames()\n\n      const pluginOptions = getPluginOptions()\n\n      const isAnInterfaceTypeOfGatsbyNodes =\n        // if this is an interface\n        field.type.kind === `INTERFACE` &&\n        // and every possible type is a future gatsby node\n        store\n          .getState()\n          // get the full type for this interface\n          .remoteSchema.typeMap.get(findTypeName(field.type))\n          // filter out any excluded types\n          .possibleTypes?.filter(\n            possibleType =>\n              !typeIsExcluded({\n                pluginOptions,\n                typeName: possibleType.name,\n              })\n          )\n          // if every remaining type is a Gatsby node type\n          // then use this field transformer\n          ?.every(possibleType => gatsbyNodeTypes.includes(possibleType.name))\n\n      return (\n        (gatsbyNodeTypes.includes(field.type.name) &&\n          field.type.kind === `OBJECT`) ||\n        isAnInterfaceTypeOfGatsbyNodes\n      )\n    },\n\n    transform: transformGatsbyNodeObject,\n  },\n\n  {\n    description: `Lists of Gatsby Node Object types`,\n    test: field => {\n      const gatsbyNodeTypes = getGatsbyNodeTypeNames()\n\n      const {\n        remoteSchema: { typeMap },\n      } = store.getState()\n\n      return (\n        // this is a list of Gatsby nodes\n        (field.type.kind === `LIST` &&\n          field.type.ofType.kind === `OBJECT` &&\n          gatsbyNodeTypes.includes(field.type.ofType.name)) ||\n        // or it's a list of an interface type which Gatsby nodes implement\n        (field.type.kind === `LIST` &&\n          field.type.ofType.kind === `INTERFACE` &&\n          typeMap\n            .get(field.type.ofType.name)\n            ?.possibleTypes?.find(possibleType =>\n              gatsbyNodeTypes.includes(possibleType.name)\n            ))\n      )\n    },\n\n    transform: transformListOfGatsbyNodes,\n  },\n\n  {\n    description: `Non-Gatsby Node Objects`,\n    test: field => field.type.kind === `OBJECT`,\n    transform: ({ field }) => buildTypeName(field.type.name),\n  },\n\n  {\n    description: `Lists of Non Gatsby Node Objects`,\n    test: field =>\n      field.type.kind === `LIST` &&\n      (field.type.ofType.kind === `OBJECT` ||\n        field.type.ofType.kind === `ENUM`),\n\n    transform: ({ field }) => `[${buildTypeName(field.type.ofType.name)}]`,\n  },\n\n  {\n    description: `Lists of Union types`,\n    test: field =>\n      field.type.kind === `LIST` && field.type.ofType.kind === `UNION`,\n\n    transform: transformListOfUnions,\n  },\n\n  {\n    description: `Lists of Scalar types`,\n    test: field =>\n      field.type.kind === `LIST` && field.type.ofType.kind === `SCALAR`,\n\n    transform: ({ field }) => {\n      if (typeIsABuiltInScalar(field.type)) {\n        return `[${field.type.ofType.name}]`\n      } else {\n        return `[JSON]`\n      }\n    },\n  },\n\n  {\n    description: `Lists of Interface types`,\n    test: field =>\n      field.type.kind === `LIST` && field.type.ofType.kind === `INTERFACE`,\n\n    transform: ({ field }) => `[${buildTypeName(field.type.ofType.name)}]`,\n  },\n\n  {\n    description: `Union type`,\n    test: field => field.type.kind === `UNION`,\n    transform: transformUnion,\n  },\n\n  {\n    description: `Interface type`,\n    test: field => field.type.kind === `INTERFACE`,\n    transform: ({ field }) => buildTypeName(field.type.name),\n  },\n\n  {\n    description: `Lists of NON_NULL types`,\n    test: field =>\n      findTypeKind(field.type) !== `LIST` && field.type.kind === `NON_NULL`,\n    transform: ({ field }) => `${buildTypeName(findTypeName(field.type))}!`,\n  },\n\n  // for finding unhandled types\n  // {\n  //   description: `Unhandled type`,\n  //   test: () => true,\n  //   transform: ({ field }) => dd(field),\n  // },\n]\n"],"mappings":"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"}