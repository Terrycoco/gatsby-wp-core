{"version":3,"file":"helpers.js","names":["buildTypeName","name","schema","typePrefix","prefix","getPluginOptions","startsWith","findTypeName","type","ofType","findTypeKind","kind","fieldOfTypeWasFetched","fetchedTypes","store","getState","remoteSchema","typeName","typeWasFetched","get","supportedScalars","typeIsABuiltInScalar","includes","typeIsASupportedScalar","typeSettingCache","getTypeSettingsByType","cachedTypeSettings","allTypeSettings","gatsbyApi","pluginOptions","typeSettings","__allTypeSetting","__all","limit","mergedSettings","filterTypeDefinition","typeDefinition","typeBuilderApi","typeKind","filters","typeDefinitionFilters","filter","length","forEach","typeDef"],"sources":["../../../src/steps/create-schema-customization/helpers.js"],"sourcesContent":["import store from \"~/store\"\nimport { typeDefinitionFilters } from \"./type-filters\"\nimport { getPluginOptions } from \"~/utils/get-gatsby-api\"\nimport { cloneDeep, merge } from \"lodash\"\n\n/**\n * This function namespaces typenames with a prefix\n */\nexport const buildTypeName = name => {\n  if (!name || typeof name !== `string`) {\n    return null\n  }\n\n  const {\n    schema: { typePrefix: prefix },\n  } = getPluginOptions()\n\n  // this is for our namespace type on the root { wp { ...fields } }\n  if (name === prefix) {\n    return name\n  }\n\n  if (name === `Filter`) {\n    name = `FilterType`\n  }\n\n  if (name.startsWith(prefix)) {\n    return name\n  }\n\n  return prefix + name\n}\n\n/**\n * Find the first type name of a Type definition pulled via introspection\n * @param {object} type\n */\nexport const findTypeName = type =>\n  type?.name ||\n  type?.ofType?.name ||\n  type?.ofType?.ofType?.name ||\n  type?.ofType?.ofType?.ofType?.name\n\n/**\n * Find the first type kind of a Type definition pulled via introspection\n * @param {object} type\n */\nexport const findTypeKind = type =>\n  type?.kind ||\n  type?.ofType?.kind ||\n  type?.ofType?.ofType?.kind ||\n  type?.ofType?.ofType?.ofType?.kind\n\nexport const fieldOfTypeWasFetched = type => {\n  const { fetchedTypes } = store.getState().remoteSchema\n  const typeName = findTypeName(type)\n  const typeWasFetched = !!fetchedTypes.get(typeName)\n\n  return typeWasFetched\n}\n\nconst supportedScalars = [\n  `Int`,\n  `Float`,\n  `String`,\n  `Boolean`,\n  `ID`,\n  `Date`,\n  `JSON`,\n]\n\nexport const typeIsABuiltInScalar = type =>\n  // @todo the next function and this one are redundant.\n  // see the next todo on how to fix the issue. If that todo is resolved, these functions will be identical. :(\n  supportedScalars.includes(findTypeName(type))\n\nexport const typeIsASupportedScalar = type => {\n  if (findTypeKind(type) !== `SCALAR`) {\n    // @todo returning true here seems wrong since a type that is not a scalar can't be a supported scalar... so there is some other logic elsewhere that is wrong\n    // making this return false causes errors in the schema\n    return true\n  }\n\n  return supportedScalars.includes(findTypeName(type))\n}\n\nconst typeSettingCache = {}\n\n// retrieves plugin settings for the provided type\nexport const getTypeSettingsByType = type => {\n  if (!type) {\n    return {}\n  }\n\n  const typeName = findTypeName(type)\n\n  const cachedTypeSettings = typeSettingCache[typeName]\n\n  if (cachedTypeSettings) {\n    return cachedTypeSettings\n  }\n\n  // the plugin options object containing every type setting\n  const allTypeSettings = store.getState().gatsbyApi.pluginOptions.type\n\n  const typeSettings = cloneDeep(allTypeSettings[typeName] || {})\n\n  // the type.__all plugin option which is applied to every type setting\n  const __allTypeSetting = cloneDeep(allTypeSettings.__all || {})\n\n  if (typeName === `MediaItem`) {\n    delete __allTypeSetting.limit\n    delete typeSettings.limit\n  }\n\n  if (typeSettings) {\n    const mergedSettings = merge(__allTypeSetting, typeSettings)\n\n    typeSettingCache[typeName] = mergedSettings\n\n    return mergedSettings\n  }\n\n  typeSettingCache[typeName] = __allTypeSetting\n\n  return __allTypeSetting\n}\n\n/**\n * This is used to filter the automatically generated type definitions before they're added to the schema customization api.\n */\nexport const filterTypeDefinition = (\n  typeDefinition,\n  typeBuilderApi,\n  typeKind\n) => {\n  const filters = typeDefinitionFilters.filter(filter =>\n    [typeBuilderApi.type.name, `__all`].includes(filter.typeName)\n  )\n\n  if (filters?.length) {\n    filters.forEach(filter => {\n      if (filter && typeof filter.typeDef === `function`) {\n        typeDefinition = filter.typeDef(\n          typeDefinition,\n          typeBuilderApi,\n          typeKind\n        )\n      }\n    })\n  }\n\n  return typeDefinition\n}\n"],"mappings":";;;;;;;;;;;AAAA;;AACA;;AACA;;AAGA;AACA;AACA;AACO,MAAMA,aAAa,GAAGC,IAAI,IAAI;EACnC,IAAI,CAACA,IAAD,IAAS,OAAOA,IAAP,KAAiB,QAA9B,EAAuC;IACrC,OAAO,IAAP;EACD;;EAED,MAAM;IACJC,MAAM,EAAE;MAAEC,UAAU,EAAEC;IAAd;EADJ,IAEF,IAAAC,8BAAA,GAFJ,CALmC,CASnC;;EACA,IAAIJ,IAAI,KAAKG,MAAb,EAAqB;IACnB,OAAOH,IAAP;EACD;;EAED,IAAIA,IAAI,KAAM,QAAd,EAAuB;IACrBA,IAAI,GAAI,YAAR;EACD;;EAED,IAAIA,IAAI,CAACK,UAAL,CAAgBF,MAAhB,CAAJ,EAA6B;IAC3B,OAAOH,IAAP;EACD;;EAED,OAAOG,MAAM,GAAGH,IAAhB;AACD,CAvBM;AAyBP;AACA;AACA;AACA;;;;;AACO,MAAMM,YAAY,GAAGC,IAAI;EAAA;;EAAA,OAC9B,CAAAA,IAAI,SAAJ,IAAAA,IAAI,WAAJ,YAAAA,IAAI,CAAEP,IAAN,MACAO,IADA,aACAA,IADA,uCACAA,IAAI,CAAEC,MADN,iDACA,aAAcR,IADd,MAEAO,IAFA,aAEAA,IAFA,wCAEAA,IAAI,CAAEC,MAFN,0EAEA,cAAcA,MAFd,yDAEA,qBAAsBR,IAFtB,MAGAO,IAHA,aAGAA,IAHA,wCAGAA,IAAI,CAAEC,MAHN,0EAGA,cAAcA,MAHd,kFAGA,qBAAsBA,MAHtB,0DAGA,sBAA8BR,IAH9B,CAD8B;AAAA,CAAzB;AAMP;AACA;AACA;AACA;;;;;AACO,MAAMS,YAAY,GAAGF,IAAI;EAAA;;EAAA,OAC9B,CAAAA,IAAI,SAAJ,IAAAA,IAAI,WAAJ,YAAAA,IAAI,CAAEG,IAAN,MACAH,IADA,aACAA,IADA,wCACAA,IAAI,CAAEC,MADN,kDACA,cAAcE,IADd,MAEAH,IAFA,aAEAA,IAFA,wCAEAA,IAAI,CAAEC,MAFN,0EAEA,cAAcA,MAFd,yDAEA,qBAAsBE,IAFtB,MAGAH,IAHA,aAGAA,IAHA,wCAGAA,IAAI,CAAEC,MAHN,0EAGA,cAAcA,MAHd,kFAGA,qBAAsBA,MAHtB,0DAGA,sBAA8BE,IAH9B,CAD8B;AAAA,CAAzB;;;;AAMA,MAAMC,qBAAqB,GAAGJ,IAAI,IAAI;EAC3C,MAAM;IAAEK;EAAF,IAAmBC,cAAA,CAAMC,QAAN,GAAiBC,YAA1C;;EACA,MAAMC,QAAQ,GAAGV,YAAY,CAACC,IAAD,CAA7B;EACA,MAAMU,cAAc,GAAG,CAAC,CAACL,YAAY,CAACM,GAAb,CAAiBF,QAAjB,CAAzB;EAEA,OAAOC,cAAP;AACD,CANM;;;AAQP,MAAME,gBAAgB,GAAG,CACtB,KADsB,EAEtB,OAFsB,EAGtB,QAHsB,EAItB,SAJsB,EAKtB,IALsB,EAMtB,MANsB,EAOtB,MAPsB,CAAzB;;AAUO,MAAMC,oBAAoB,GAAGb,IAAI,IACtC;AACA;AACAY,gBAAgB,CAACE,QAAjB,CAA0Bf,YAAY,CAACC,IAAD,CAAtC,CAHK;;;;AAKA,MAAMe,sBAAsB,GAAGf,IAAI,IAAI;EAC5C,IAAIE,YAAY,CAACF,IAAD,CAAZ,KAAwB,QAA5B,EAAqC;IACnC;IACA;IACA,OAAO,IAAP;EACD;;EAED,OAAOY,gBAAgB,CAACE,QAAjB,CAA0Bf,YAAY,CAACC,IAAD,CAAtC,CAAP;AACD,CARM;;;AAUP,MAAMgB,gBAAgB,GAAG,EAAzB,C,CAEA;;AACO,MAAMC,qBAAqB,GAAGjB,IAAI,IAAI;EAC3C,IAAI,CAACA,IAAL,EAAW;IACT,OAAO,EAAP;EACD;;EAED,MAAMS,QAAQ,GAAGV,YAAY,CAACC,IAAD,CAA7B;EAEA,MAAMkB,kBAAkB,GAAGF,gBAAgB,CAACP,QAAD,CAA3C;;EAEA,IAAIS,kBAAJ,EAAwB;IACtB,OAAOA,kBAAP;EACD,CAX0C,CAa3C;;;EACA,MAAMC,eAAe,GAAGb,cAAA,CAAMC,QAAN,GAAiBa,SAAjB,CAA2BC,aAA3B,CAAyCrB,IAAjE;;EAEA,MAAMsB,YAAY,GAAG,yBAAUH,eAAe,CAACV,QAAD,CAAf,IAA6B,EAAvC,CAArB,CAhB2C,CAkB3C;;EACA,MAAMc,gBAAgB,GAAG,yBAAUJ,eAAe,CAACK,KAAhB,IAAyB,EAAnC,CAAzB;;EAEA,IAAIf,QAAQ,KAAM,WAAlB,EAA8B;IAC5B,OAAOc,gBAAgB,CAACE,KAAxB;IACA,OAAOH,YAAY,CAACG,KAApB;EACD;;EAED,IAAIH,YAAJ,EAAkB;IAChB,MAAMI,cAAc,GAAG,qBAAMH,gBAAN,EAAwBD,YAAxB,CAAvB;IAEAN,gBAAgB,CAACP,QAAD,CAAhB,GAA6BiB,cAA7B;IAEA,OAAOA,cAAP;EACD;;EAEDV,gBAAgB,CAACP,QAAD,CAAhB,GAA6Bc,gBAA7B;EAEA,OAAOA,gBAAP;AACD,CArCM;AAuCP;AACA;AACA;;;;;AACO,MAAMI,oBAAoB,GAAG,CAClCC,cADkC,EAElCC,cAFkC,EAGlCC,QAHkC,KAI/B;EACH,MAAMC,OAAO,GAAGC,kCAAA,CAAsBC,MAAtB,CAA6BA,MAAM,IACjD,CAACJ,cAAc,CAAC7B,IAAf,CAAoBP,IAArB,EAA4B,OAA5B,EAAoCqB,QAApC,CAA6CmB,MAAM,CAACxB,QAApD,CADc,CAAhB;;EAIA,IAAIsB,OAAJ,aAAIA,OAAJ,eAAIA,OAAO,CAAEG,MAAb,EAAqB;IACnBH,OAAO,CAACI,OAAR,CAAgBF,MAAM,IAAI;MACxB,IAAIA,MAAM,IAAI,OAAOA,MAAM,CAACG,OAAd,KAA2B,UAAzC,EAAoD;QAClDR,cAAc,GAAGK,MAAM,CAACG,OAAP,CACfR,cADe,EAEfC,cAFe,EAGfC,QAHe,CAAjB;MAKD;IACF,CARD;EASD;;EAED,OAAOF,cAAP;AACD,CAtBM"}